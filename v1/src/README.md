### 剑指Offer

+ 有序的二位数组中查找给定元素
    > 从右上角的元素考虑, target大于该元素, 则对应行不用考虑, target小于该元素则对应列不用考虑
    
+ 替换空格

+ 从尾到头打印空格

+ 重建二叉树
    - [x] 递归
        >  1)由前序的第一个元素确定根节点  
        2)用该元素在中序序列的位置将元素分成左子树和右子树两个部分  
        3)递归调用上面的方法构建
        
+ 两个栈模拟队列

+ 旋转数组的最小值

+ 斐波那契数列
    > 用一个数组保存计算结果, 避免重复计算
    
+ 跳台阶
    > 可以转化成一个斐波那契数列问题求解, n=1 (1), n=2 (2)
    
+ 变态跳台阶
    > 类似于斐波那契数列, 从前面任意一种情况都可以直接到达台阶n, 注意考虑直接n步
    
+ 矩形覆盖
    > 可以考虑大矩形的构造过程, n=1, n=2, n=3时相当于在n=1或n=2的基础上横着或或者加入小矩形
    ,同样转化成斐波那契数列问题
    
    
+ 调整数组顺序使奇数位于偶数前面
    > 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
    - [x] 从后先前扫描遇到偶数就一直向后交换, 直到遇到另一个偶数或到末尾
    
+ 二叉树的镜像
    - [x] 递归
    
+ 顺时针打印矩阵
    > 每次打印一圈, 上下左右四个部分, 打印完向内缩小一圈, 最后可能剩余一行、一列或一个元素
    
+ 包含Min函数的栈
    > 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
    > 
    > 定义两个栈, 一个存放数据, 一个存放最小数据(依次将遇到的最小数据压栈)  
    > 注意pop的时候, 如果pop的值的辅助栈栈顶的值相同时, 辅助栈也要pop
    
+ 栈的压入弹出序列  
    [参考](https://www.cnblogs.com/edisonchou/p/4779755.html)  
    > 具体参考代码注释
    
+ 从上往下打印二叉树
    > 二叉树的层序遍历, 借助队列实现
    
+ 二叉搜索树的后序序列  
    > 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。  
    如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。  
    最后一个元素为root, 找到左右子树, 分别判断左右子树是否为合法的后序序列;  
    注意: 找左右子树是要保证左边小于root右边大于root, 考虑左右子树为空的情形
    
+ 二叉树中和为某一值的路径
    > 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)  
    
    > 思路:分解成子问题, 对两个子树分别找和为另一个值的路径, 递归的进行下去, 当一个节点为left node的时候根据是否相等返回即可。